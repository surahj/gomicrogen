package generator

import (
	"encoding/json"
	"fmt"
	"html"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Choplife-group/gomicrogen/internal/config"
)

// TemplateGenerator handles the generation of files from templates
type TemplateGenerator struct {
	templatesDir string
	config       *config.ServiceConfig
}

// NewTemplateGenerator creates a new template generator
func NewTemplateGenerator(templatesDir string, config *config.ServiceConfig) *TemplateGenerator {
	return &TemplateGenerator{
		templatesDir: templatesDir,
		config:       config,
	}
}

// GenerateService creates the complete service structure from templates
func (tg *TemplateGenerator) GenerateService(targetDir string) error {
	// Create target directory
	if err := os.MkdirAll(targetDir, 0755); err != nil {
		return fmt.Errorf("failed to create target directory: %w", err)
	}

	// Walk through templates directory and generate files
	return filepath.WalkDir(tg.templatesDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Skip the templates directory itself
		if path == tg.templatesDir {
			return nil
		}

		// Skip auto-generated files that shouldn't be templated
		if shouldSkipFile(path) {
			return nil
		}

		// Get relative path from templates directory
		relPath, err := filepath.Rel(tg.templatesDir, path)
		if err != nil {
			return fmt.Errorf("failed to get relative path: %w", err)
		}

		// Determine target path
		targetPath := filepath.Join(targetDir, relPath)

		// Handle special file names
		if strings.HasSuffix(targetPath, ".tmpl") {
			targetPath = strings.TrimSuffix(targetPath, ".tmpl")
		}

		// Special handling for env.tmpl -> .env
		if strings.HasSuffix(targetPath, "env") && !strings.HasPrefix(filepath.Base(targetPath), ".") {
			targetPath = filepath.Join(filepath.Dir(targetPath), ".env")
		}

		if d.IsDir() {
			// Create directory
			return os.MkdirAll(targetPath, 0755)
		} else {
			// Generate file from template
			return tg.generateFile(path, targetPath)
		}
	})
}

// shouldSkipFile determines if a file should be skipped during templating
func shouldSkipFile(path string) bool {
	fileName := filepath.Base(path)

	// Skip auto-generated files
	skipFiles := []string{
		"go.sum",  // Auto-generated by go mod
		"*.pb.go", // Auto-generated protobuf files
	}

	// Skip directories that shouldn't be templated
	skipDirs := []string{
		"tmp", // Temporary files
	}

	// Check if path contains any skip directories
	for _, skipDir := range skipDirs {
		if strings.Contains(path, "/"+skipDir+"/") || strings.Contains(path, "\\"+skipDir+"\\") {
			return true
		}
	}

	for _, skipFile := range skipFiles {
		if strings.Contains(skipFile, "*") {
			// Handle wildcard patterns
			pattern := strings.ReplaceAll(skipFile, "*", "")
			if strings.Contains(fileName, pattern) {
				return true
			}
		} else if fileName == skipFile {
			return true
		}
	}

	return false
}

// shouldCopyAsIs determines if a file should be copied as-is without template processing
func shouldCopyAsIs(path string) bool {
	fileName := filepath.Base(path)

	// Files that should be copied as-is (not processed as templates)
	copyAsIsFiles := []string{
		"docs.go",      // Generated swagger docs
		"swagger.json", // Swagger JSON spec
		"swagger.yaml", // Swagger YAML spec
	}

	for _, copyFile := range copyAsIsFiles {
		if fileName == copyFile {
			return true
		}
	}

	return false
}

// generateFile generates a single file from a template
func (tg *TemplateGenerator) generateFile(templatePath, targetPath string) error {
	// Read template content
	content, err := os.ReadFile(templatePath)
	if err != nil {
		return fmt.Errorf("failed to read template file %s: %w", templatePath, err)
	}

	// Check if this is a non-template file that should be copied as-is
	if shouldCopyAsIs(templatePath) {
		// Create target directory if it doesn't exist
		targetDir := filepath.Dir(targetPath)
		if err := os.MkdirAll(targetDir, 0755); err != nil {
			return fmt.Errorf("failed to create target directory %s: %w", targetDir, err)
		}

		// Create target file
		file, err := os.Create(targetPath)
		if err != nil {
			return fmt.Errorf("failed to create target file %s: %w", targetPath, err)
		}
		defer file.Close()

		// Write content directly without template processing
		if _, err := file.Write(content); err != nil {
			return fmt.Errorf("failed to write target file %s: %w", targetPath, err)
		}

		fmt.Printf("Copied: %s\n", targetPath)
		return nil
	}

	// Create template with custom functions
	funcMap := template.FuncMap{
		"upper": strings.ToUpper,
		"lower": strings.ToLower,
		"title": strings.Title,
		"marshal": func(v interface{}) string {
			a, _ := json.Marshal(v)
			return string(a)
		},
		"escape": html.EscapeString,
	}

	tmpl, err := template.New(filepath.Base(templatePath)).Funcs(funcMap).Parse(string(content))
	if err != nil {
		return fmt.Errorf("failed to parse template %s: %w", templatePath, err)
	}

	// Create target directory if it doesn't exist
	targetDir := filepath.Dir(targetPath)
	if err := os.MkdirAll(targetDir, 0755); err != nil {
		return fmt.Errorf("failed to create target directory %s: %w", targetDir, err)
	}

	// Create target file
	file, err := os.Create(targetPath)
	if err != nil {
		return fmt.Errorf("failed to create target file %s: %w", targetPath, err)
	}
	defer file.Close()

	// Execute template
	if err := tmpl.Execute(file, tg.config); err != nil {
		return fmt.Errorf("failed to execute template %s: %w", templatePath, err)
	}

	fmt.Printf("Generated: %s\n", targetPath)
	return nil
}
